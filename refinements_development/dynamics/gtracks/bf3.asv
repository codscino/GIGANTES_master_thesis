clc;
clear all;
close all;

%% ========================================================================
%  1. DEFINE INPUTS & INITIALIZE
%  ========================================================================

% --- Flyby and Central Body Parameters ---
pars.INPUTS.idCentral = 6;      % Central Body: Saturn
pars.INPUTS.idMoon    = 1;      % Enceladus flyby
pars.INPUTS.V_inf     = 4.0;    % Hyperbolic excess velocity at Enceladus [km/s]
pars.INPUTS.Flyby.min_h = 25;   % Minimum flyby altitude [km]

% --- Define Incoming and Outgoing Asymptotes (Nodes) ---
nodein =  [pars.INPUTS.V_inf, 0.15, 0];            % [km/s, rad, rad]
nodeout = [pars.INPUTS.V_inf, 0.15, deg2rad(1)];   % [km/s, rad, rad]

% --- SPICE and Time Parameters ---
kernels = {'de440.bsp', 'sat441.bsp', 'naif0012.tls', 'pck00010.tpc'};
loadSpiceKernels(kernels); 

spiceParam.frame    = 'J2000';
spiceParam.abcorr   = 'NONE';
spiceParam.observer = '699'; % Saturn Center NAIF ID
pars.INPUTS.epoch0  = date2mjd2000([2035, 1, 1, 0, 0, 0]);

% --- Define Perturbations (Saturn + Enceladus ONLY) ---
perturbingBodyNaifIDs = [602]; % Enceladus NAIF ID

% --- Load Gravitational Parameters ---
mu_central_body = getAstroConstants('Saturn', 'Mu');
[~, mu_enceladus, R_enceladus, ~] = satMoonsConstants(1); % Enceladus
mu_TBs = mu_enceladus;

% Retrieve Saturn Parameters 
[pars.Planet.mu, pars.Planet.EquRad, pars.Planet.OrbRad, pars.Planet.hmin] = planetConstants(pars.INPUTS.idCentral);

% Retrieve Desired Moon Parameters 
if pars.INPUTS.idCentral == 6
    [pars.Moon.OrbRad, pars.Moon.mu, pars.Moon.EquRad, pars.Moon.hmin] = satMoonsConstants(pars.INPUTS.idMoon);
end
pars.Moon.Vel    = sqrt(pars.Planet.mu/pars.Moon.OrbRad);
pars.Moon.Period = 2*pi*sqrt(pars.Moon.OrbRad^3/pars.Planet.mu);
pars.Moon.HillSph = pars.Moon.OrbRad*( pars.Moon.mu/(3*(pars.Moon.mu + pars.Planet.mu)))^(1/3);

% --- Parameters required for Linked Conic Calculation ---
pars.GroundTr.npoints      = 30e3; 
pars.GroundTr.t_prop       = 5;    
pars.INPUTS.Flyby.hMapping = 300;


%% ========================================================================
%  2. CALCULATE INITIAL PERICENTER STATE FOR PROPAGATION
%  ========================================================================

[r_enceladus_at_flyby, v_enceladus_at_flyby] = EphSS_car_spice2(602, pars.INPUTS.epoch0 , true, spiceParam);
[vvinfin, ~, ~, ~] = vinfAlphaCrank_to_VinfCARTClaudio(nodein(1), nodein(2), nodein(3), pars.INPUTS.epoch0, pars.INPUTS.idMoon, pars.INPUTS.idCentral);
[vvinfout, r0_sc_out, v0_sc_out, vvga] = vinfAlphaCrank_to_VinfCARTClaudio(nodeout(1), nodeout(2), nodeout(3), pars.INPUTS.epoch0, pars.INPUTS.idMoon, pars.INPUTS.idCentral );

rp_flyby  = pars.INPUTS.Flyby.min_h + pars.Moon.EquRad;
e_fly     = 1 + ((rp_flyby*pars.INPUTS.V_inf^2)/pars.Moon.mu);
delta_max = 2*asin(1/e_fly);
pars.delta_max = delta_max;

b1 = -r0_sc_out./norm(r0_sc_out);
b3 = cross(r0_sc_out, vvga)./norm(cross(r0_sc_out, vvga));
b2 = cross(b3,b1);
Rm = [ b1' b2' b3' ]';

[vvinfouBM, delta] = infVelBeforeDefect(vvinfin, vvinfout, delta_max, vvga);
vvinfin_bf = [Rm*vvinfin']';
vvinfouBM_bf = [Rm*vvinfouBM']';

Energy = 0.5*norm(vvinfin_bf)^2;
sma = -mu_enceladus/(2*Energy);
ecc = 1/(sin(delta/2));
rp = sma*(1 - ecc);
hhat = cross(vvinfin_bf, vvinfouBM_bf)./norm(cross(vvinfin_bf, vvinfouBM_bf));
vp = sqrt(norm(vvinfin_bf)^2 + 2*mu_enceladus/rp);

rrp_bf = rp.*(vvinfin_bf - vvinfouBM_bf)./norm(vvinfin_bf - vvinfouBM_bf);
vvp_bf = vp.*cross(hhat, rrp_bf./rp);

Rm_inv = Rm';
rrp_saturn_centric = (Rm_inv * rrp_bf')' + r_enceladus_at_flyby;
vvp_saturn_centric = (Rm_inv * vvp_bf')' + v_enceladus_at_flyby;

rrp_saturn_centric = rrp_saturn_centric(:);
vvp_saturn_centric = vvp_saturn_centric(:);

%% ========================================================================
%  3. PROPAGATE THE TRAJECTORIES
%  ========================================================================

propagation_duration_days = 0.1;
duration_sec = propagation_duration_days * 86400;
time_steps = 30e3;
time_vector_fwd = linspace(0, duration_sec, time_steps)';
time_vector_bwd = linspace(0, -duration_sec, time_steps)';

ephem_handle = @(t_sec) get_body_positions_wrapper(t_sec, pars.INPUTS.epoch0, perturbingBodyNaifIDs, spiceParam);
[~, state_out_fwd] = propagateNBodyODE2(rrp_saturn_centric, vvp_saturn_centric, time_vector_fwd, mu_central_body, mu_TBs, ephem_handle, []);
[time_out_bwd, state_out_bwd] = propagateNBodyODE2(rrp_saturn_centric, vvp_saturn_centric, time_vector_bwd, mu_central_body, mu_TBs, ephem_handle, []);

time_out_bwd = flipud(time_out_bwd);
state_out_bwd = flipud(state_out_bwd);
full_time_out = [time_out_bwd; time_vector_fwd(2:end)];
full_state_out = [state_out_bwd; state_out_fwd(2:end, :)];
num_steps = length(full_time_out);

%% ========================================================================
%  4. PREPARE DATA FOR PLOTTING
%  ========================================================================
disp('Preparing data for plotting...');

% --- Calculate the full position history of Enceladus ---
r_enc_history = zeros(num_steps, 3);
for i = 1:num_steps
    current_mjd = pars.INPUTS.epoch0 + full_time_out(i) / 86400;
    [r_enc, ~] = EphSS_car_spice2(602, current_mjd, true, spiceParam);
    r_enc_history(i, :) = r_enc;
end

% --- Compute N-Body ground track ---
disp('Computing N-body ground track...');
lats = zeros(num_steps, 1);
longs = zeros(num_steps, 1);
alts = zeros(num_steps, 1);
for i = 1:num_steps
    current_mjd = pars.INPUTS.epoch0  + full_time_out(i) / 86400;
    sc_pos_icrf = full_state_out(i, 1:3); 
    r_enc = r_enc_history(i, :);
    
    % r_iau_unit_vec = icrf2enceladus(sc_pos_icrf, r_enc, current_mjd);
    % 
    % lon_rad_temp = atan2(r_iau_unit_vec(2), r_iau_unit_vec(1));
    % longs(i) = lon_rad_temp + (lon_rad_temp < 0) * 2 * pi;
    % lats(i) = asin(r_iau_unit_vec(3));
    % 
    % sc_pos_relative = sc_pos_icrf - r_enc;
    % alts(i) = norm(sc_pos_relative) - pars.Moon.EquRad;

     % --- TRANSFORMATION USING Rm (APPROXIMATION) ---

    % 1. Translate: Get S/C position relative to Enceladus(stiil ICRF)
    sc_pos_relative_icrf = sc_pos_icrf - r_enc;

    % This transforms the vector into the static flyby geometry frame.
    r_in_flyby_frame = (Rm * sc_pos_relative_icrf')';
    
    % 3. Calculate "latitude" and "longitude" based on this static frame.
    % and nomralize the vector to get the angles correctly.
    r_in_flyby_frame_unit = r_in_flyby_frame / norm(r_in_flyby_frame);

    lon_rad_temp = atan2(r_in_flyby_frame_unit(2), r_in_flyby_frame_unit(1));
    lats(i) = asin(r_in_flyby_frame_unit(3));

    longs   = wrapTo2Pi(longs);
long = wrapTo360(long);
    
    % Altitude is a scalar distance, so it is calculated from the relative
    % vector before rotation and is unaffected by the approximation.
    alts(i) = norm(sc_pos_relative_icrf) - pars.Moon.EquRad;
end
lats_deg = rad2deg(lats);
longs_deg = rad2deg(longs);
[~, idx_periapsis] = min(alts);

% --- Compute Linked Conic reference ground track ---
disp('Computing reference linked conic groundtrack...');
[Flyby_LinkedConic] = Flyby_BuildUp(nodein, nodeout, pars);

%% ========================================================================
%  5. PLOT TRAJECTORIES AND GROUND TRACKS
%  ========================================================================
disp('Generating plots...');

% --- Create a new, wider figure with a white background ---
figure('Name', 'Trajectory and Ground Track Analysis', 'Color', 'w', 'Position', [100 100 1400 600]);

% --- LEFT SUBPLOT: 3D Static Trajectory Plot ---
ax1 = subplot(1, 2, 1);
hold(ax1, 'on');

% Plot the full trajectories
plot3(ax1, full_state_out(:,1), full_state_out(:,2), full_state_out(:,3), 'b-', 'LineWidth', 2, 'DisplayName', 'Spacecraft');
plot3(ax1, r_enc_history(:,1), r_enc_history(:,2), r_enc_history(:,3), 'g-', 'LineWidth', 1.5, 'DisplayName', 'Enceladus');

% --- Define colors and styles from Plot_Flyby_GT for consistency ---
color_exit = [0.9290 0.6940 0.1250]; % Gold/Orange for exit
marker_size_3d = 6;

% Plot start, end, and pericenter points with matching styles
plot3(ax1, full_state_out(1,1), full_state_out(1,2), full_state_out(1,3), ...
    'o', 'MarkerFaceColor', 'blue', 'MarkerEdgeColor', 'black', 'MarkerSize', marker_size_3d, ...
    'DisplayName', 'Flyby Entry Point');

plot3(ax1, full_state_out(end,1), full_state_out(end,2), full_state_out(end,3), ...
    'o', 'MarkerFaceColor', color_exit, 'MarkerEdgeColor', 'black', 'MarkerSize', marker_size_3d, ...
    'DisplayName', 'Flyby Exit Point');

plot3(ax1, rrp_saturn_centric(1), rrp_saturn_centric(2), rrp_saturn_centric(3), ...
    'o', 'MarkerFaceColor', 'red', 'MarkerEdgeColor', 'black', 'MarkerSize', marker_size_3d, ...
    'DisplayName', 'Flyby Periapsis');

% Formatting
title(ax1, 'Spacecraft and Enceladus Trajectory (ICRF)');
xlabel(ax1, 'X [km]');
ylabel(ax1, 'Y [km]');
zlabel(ax1, 'Z [km]');
legend(ax1, 'show', 'Location', 'northeast');
grid(ax1, 'on');
axis(ax1, 'equal');
view(ax1, 3);

% --- RIGHT SUBPLOT: Ground Track Comparison ---
ax2 = subplot(1, 2, 2);
hold(ax2, 'on');

% --- Filter data for mapping altitude ---
mapping_altitude_km = pars.INPUTS.Flyby.hMapping;
valid_indices = alts <= mapping_altitude_km;
NBody_Mapping_Data.lats = lats(valid_indices);
NBody_Mapping_Data.longs = longs(valid_indices);
NBody_Mapping_Data.rp_lat = lats_deg(idx_periapsis);
NBody_Mapping_Data.rp_long = longs_deg(idx_periapsis);

% Plot the moon texture map
plotTextureLatLong(pars.INPUTS.idMoon, pars.INPUTS.idCentral, 1); 
axis(ax2, 'normal');
grid(ax2, 'on');
title(ax2, ['Ground Track Comparison (Altitude \leq ' num2str(mapping_altitude_km) ' km)']);

% Plot N-Body Ground Track (Orange)
if ~isempty(NBody_Mapping_Data.lats)
    disp('Plotting N-Body Track...')
    Plot_Flyby_GT(NBody_Mapping_Data, [0.8500, 0.3250, 0.0980]); 
end

% Plot Linked Conic Ground Track (Blue)
if ~isempty(Flyby_LinkedConic)
     disp('Plotting Linked Conic Track...')
     Plot_Flyby_GT(Flyby_LinkedConic, [0, 0.4470, 0.7410]);
end

% Reset the legend to only show the main track types, as Plot_Flyby_GT creates its own detailed legends.
h = zeros(2, 1);
h(1) = plot(ax2, NaN,NaN,'-', 'Color', [0.8500, 0.3250, 0.0980], 'LineWidth', 2);
h(2) = plot(ax2, NaN,NaN,'-', 'Color', [0, 0.4470, 0.7410], 'LineWidth', 2);
legend(h, 'N-Body Propagation', 'Linked Conic Approx.', 'Location', 'best');

hold(ax1, 'off');
hold(ax2, 'off');
disp('Plotting finished.');

%% ========================================================================
%  HELPER FUNCTIONS
%  ========================================================================
function positions = get_body_positions_wrapper(t_sec, t0_mjd_start, naif_ids, sp_param)
    current_mjd = t0_mjd_start + t_sec / 86400;
    num_bodies = length(naif_ids);
    positions = zeros(3, num_bodies);
    
    for k = 1:num_bodies
        [r, ~] = EphSS_car_spice2(naif_ids(k), current_mjd, true, sp_param);
        positions(:, k) = r(:); % Ensure column vector
    end
end

